# 객체지향  프로그래밍
- 프로그래밍의 중요한 패러다임 중 하나로, 프로그램을 일련의 독립된 객체들로 이해하는 방법론입니다.
- 프로그램을 수많은 객체(object)라는 기본 단위로 나누고 각각의 객체들은 고유한 데이터와 해당 데이터를 조작하는 메소드를 보유하고있습니다.


## 객체지향 프로그래밍의 특징
  1. 캡슐화
      - 캡슐화는 객체의 속성(data fields)과 행위(methods)를 함께 묶는 과정을 의미합니다. 이는 데이터를 직접 조작하지 않고 메소드를 통해 간접적으로 접근하도록 제한하여 데이터 보호를 제공합니다
  2. 상속
      - 상속은 새로운 클래스가 기존 클래스의 속성과 메소드를 이어받을 수 있게 하는 메커니즘입니다. 이를 통해 코드의 재사용성을 높이고 코드의 길이를 줄일 수 있습니다.
  3. 다형성
      -  다형성은 같은 이름의 메소드가 다른 동작을 수행할 수 있도록 하는 원리입니다. 즉, 메소드가 어떤 클래스에 속해 있는지에 따라 다른 기능을 수행하도록 설계될 수 있습니다.

## SOLID원칙
  1. SRP(Single responsibility principle) : 단일 책임 원칙
  2. OCP(Open-closed principle) : 개방-폐쇄 원칙
  3. LSP(Liskov substitution principle) : 리스코프 치환 원칙
  4. ISP(Interface segregation principle) : 인터페이스 분리 원칙
  5. DIP(Dependency inversion principle) : 의존관계 역전 원칙

### 1. SRP - 단일 책임 원칙
  #### 한 클래스는 하나의 책임만 가져야 한다.
  - 모든 클래스는 각각 하나의 책임만 가져야 하며, 수정할 이유는 단 한 가지여야 한다.
  즉, 클래스는 그 책임을 완전히 캡슐화해야 함을 말한다.
  예를들어, 결제 클래스가 있다치면 이 클래스는 오직 결제 기능만을 책임지고,
  만약 이 클래스를 수정해야 한다면 결제에 관련된 문제일 뿐일 것이다.

### 2. OCP - 개방 페쇠 원칙
  #### 확장에는 열려있고 변경에는 닫혀있어야한다.
  - 기존의 코드를 변경하지 않으면서, 기능을 추가할 수 있도록 설계가 되는 원칙
  - 소프트웨어의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려 있어야 하지만 변경에는 폐쇄적이어야 함을 의미한다.
  - 예를들어, 캐릭터 하나를 생성한다고 할 때 각 캐릭터마다 움직임이 다를 경우,
  움직임 패턴 구현을 하위 클래스에 맡긴다면 캐릭터 클래스의 수정은 필요없고(Closed),
  움직임 패턴만 재정의 하면 된다.(Open)

### 3. LSP - 리스코프 치환 원칙
  #### 서브 타입은 언제나 자신의 기반 타입으로 변경할 수 있어야한다.
  - 상위 타입은 항상 하위 타입으로 대체될 수 있어야 함을 의미한다.
  즉, 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 역할을 하는데 문제가 없어야 한다는 의미이다.
  - 다형성과 확장성을 극대화하며, 개방-패쇠 원칙을 구성한다.

### 4. ISP -  인터페이스 분리 원칙
  #### 하나의 일반적인 인터페이스보다 여러 개의 구체적인 인터페이스가 낫다.
  - 인터페이스 내에 메소드는 최소한 일수록 좋다. 즉, 최소한의 기능만 제공하면서 하나의 역할에 집중하라는 뜻이다.
  - 단일 책임 원칙(SRP)과 인터페이스 분할 원칙(ISP)은 같은 문제에 대한 두 가지 다른 해결책이라고 볼 수 있다.
  가능한 최소한의 인터페이스를 사용하도록 하여 단일 책임을 강조한다고 볼 수 있다.
  일반적으로 ISP보다 SRP 할 것을 권장하고 있다.



### 5. DIP - 의존관계 역전 원칙
  #### 구체적인 것이 추상화된 것에 의존해야 한다. 자주 변경되는 구체 클래스에 의존하지마라.
  - 구체적인 클래스보다 상위 클래스, 인터페이스, 추상 클래스와 같이 변하지 않을 가능성이 높은 클래스와 관계를 맺으라는 것
  - DIP 원칙을 따르는 가장 인기 있는 방법은 의존성 주입(DI; Dependency Injection)을 활용하는 것이다.

  요리사와 피자 레시피

---
# JOIN
#### 두 테이블을 결합하는 연산.
데이터의 규모가 커지면서 하나의 테이블로 정보를 수용하기 어려워지면 테이블을 분할하고 테이블 간의 관계성을 부여함.

## JOIN의 종류

### 1. INNER JOIN 
   - 두 테이블에서 같은 값만 보여줌
### 2.  OUTER
  #### LEFT JOIN
   - 왼쪽 테이블을 기준으로 오른쪽의 테이블을 매치
   - 왼쪽 테이블의 한개의 레코드에 여러개의 오른쪽 테이블 레코드가 일치할 경우, 해당 왼쪽 레코드를 여러번 표시
   - 왼쪽은 무조건 표시하고, 매치되는 레코드가 없으면 NULL을 표시
  #### RIGHT JOIN
  - 오른쪽 테이블을 기준으로 왼쪽 테이블을 매치
 - LEFT JOIN에서 방향을 오른쪽으로만 바꾼 것이므로, 해당 레코드가 여러번 표시되거나 NULL이 표시
### 3. CROSS JOIN 
  - 조건에 부합하지 않는 행까지 포함시켜 결합하는 것 (모든 경우의 수를 포함)

--- 

# MVC, MVVM 패턴
## MVC 패턴
> MVC (모델-뷰-컨트롤러) 는 사용자 인터페이스, 데이터 및 논리 제어를 구현하는데 널리 사용되는 소프트웨어 디자인 패턴.
> 소프트웨어의 비즈니스 로직과 화면을 구분하는데 중점을 두고 있습니다.
### Model
> - 데이터 관리 및 비즈니스 로직을 처리하는 부분
### View
> - 비즈니스 로직의 처리 결과를 통해 유저 인터페이스가 표현되는 구간
### Controller
> - 사용자의 요청을 처리하고 Model과 View를 중개하는 역할

## MVVM 패턴
> MVVM (Model-View-ViewModel) 패턴은 Model View, View, Model의 약자로 프로그램의 비지니스
> 로직과, 프레젠테이션 로직을 UI로 명확하게 분리하는 패턴입니다.
### Model
> - 데이터와 비즈니스 로직 담당
> - 데이터를 가져오고 저장하는 역할
> - 보통 데이터베이스, 네트워크 요청 또는 파일 시스템과 같은 데이터 소스와 상호 작용한다.
### View
> - 사용자 인터페이스를 담당하는 부분

### ViewModel
> - View와 Model 사이에서 중재자 역할을 수행함.
> - View에서 발생하는 이벤트를 감지하고, 해당 이벤트에 맞는 비즈니스 로직을 수행합니다.
> - Model과 상호작용하여 데이터를 가져오거나 업데이트하고, View에 데이터를 업데이트하는 역할을 합니다.
> - View에 표시할 데이터를 가공하여 제공하는 역할을 합니다.



        
  
